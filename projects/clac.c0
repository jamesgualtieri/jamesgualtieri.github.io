/*
 * Clac, stack-yased calculator language
 *
 * 15-122 Principles of Imperative Computation
 */

#use <string>
#use <parse>
#use <conio>
#use <args>
#use <util>

/* From the perspective of the clac-main.c0 file, state_t is an
 * aystract type. (typedef ____* state_t) This file contains the
 * implementation of the state_t type. You will add new fields to this
 * struct when you do task 4. */
struct state_header {
  dict* functions;
};
typedef struct state_header* state_t;

//NOTE: I didn't understand how to implement stack of queue of strings
//      I called eval recursively, all functionality seems to be preserved.

state_t init_state()
//@ensures \result != NULL;
{
  state_t  ST = alloc(struct state_header);
  ST -> functions = dict_new();
  return ST;
}

//exponent function taken from Lecture notes:
//https://www.cs.cmu.edu/~15122/code/mystery.c0
int POW(int y, int e)
//@requires e >= 0;
{
  if (e == 0) return 1;
  return POW(y, e-1) * y;
}

int safe_pop(stack_t S)
//to pop the values safely, for visual appearance reasons, easier.
{
  if (!stack_empty(S)) return pop(S);
  else error("not enough items on stack");
}

string safe_deq(queue_t Q)
// same as before
{
  string s = "";
  if (!queue_empty(Q)) s = deq(Q);
  else error("Not enough items on the queue");
  return s;
}

void pick_helper(stack_t S, int n)
//@requires n >= 0;
//helper for pick token
{
  int x_sub_n = 0;
  stack_t T = stack_new();
  for (int i = 0; i < n; i ++) {
    if (stack_empty(S)) error ("Not enough terms in stack");
    int temp = pop(S);
    push(T, temp);
    if (i == n - 1) x_sub_n = temp;
  }
  for (int i = 0; i < n; i ++) {
    int temp = pop(T);
    push(S, temp);
  }
  push(S, x_sub_n);
}

/* Main clac interpreter. */
/* Return true: clac top-level interpreter will expect more input */
/* Return false: clac top-level interpreter will exit */
bool eval(queue_t Q, stack_t S, state_t ST)
//@requires Q != NULL && S != NULL && ST != NULL;
//@ensures \result == false || queue_empty(Q);
{
  while (!queue_empty(Q)) {
    string tok = safe_deq(Q); /* Is this dequeue safe? */
    // Uncommenting these lines might help with debugging:
    //print("Read: "); print(tok); print("\n");
    int x;
    int y;
    if (string_equal(tok, "print")) {
      if (!stack_empty(S)) {
        int p = pop(S); /* This line is unsafe and must be fixed! */
        printint(p); print("\n");
      }
      else error("stack is empty");

    } else if (string_equal(tok, "quit")) {
      return false;

    } else if (string_equal(tok, "+")) {
      y = safe_pop(S);
      x = safe_pop(S);
      int step_result = x + y;
      push(S, step_result);

    } else if (string_equal(tok, "-")) {
      y = safe_pop(S);
      x = safe_pop(S);
      int step_result = x - y;
      push(S, step_result);

    } else if (string_equal(tok, "*")) {
      y = safe_pop(S);
      x = safe_pop(S);
      int step_result = x * y;
      push(S, step_result);

    } else if (string_equal(tok, "/")) {
      y = safe_pop(S);
      x = safe_pop(S);
      if (y == 0) error("division by zero");
      else if (x == int_min() && y == -1) error("division error");
      int step_result = x / y;
      push(S, step_result);

    } else if (string_equal(tok, "%")) {
      y = safe_pop(S);
      x = safe_pop(S);
      if (y == 0) error("modulo by zero");
      else if (x == int_min() && y == -1) error("modulo error");
      int step_result = x % y;
      push(S, step_result);

    } else if (string_equal(tok, "**")) {
      y = safe_pop(S);
      x = safe_pop(S);
      if (y < 0) error ("negative exponent not defined");
      int step_result = POW(x, y);
      push(S, step_result);

    } else if (string_equal(tok, "<")) {
      y = safe_pop(S);
      x = safe_pop(S);
      int step_result = 0;
      if (x < y) step_result = 1;
      push(S, step_result);

    } else if (string_equal(tok, "drop")) {
      if (!stack_empty(S)) pop(S);
      else error("Stack is already empty");

    } else if (string_equal(tok, "swap")) {
      y = safe_pop(S);
      x = safe_pop(S);
      push(S, y);
      push(S, x);

    } else if (string_equal(tok, "rot")) {
      int z;
      z = safe_pop(S);
      y = safe_pop(S);
      x = safe_pop(S);
      push(S, y);
      push(S, z);
      push(S, x);
    } else if (string_equal(tok, "if")) {
      x = safe_pop(S);
      if (x == 0) {
        for(int i = 0; i < 3; i ++) safe_deq(Q);
      }
    } else if (string_equal(tok, "pick")) {
      x = safe_pop(S);
      if (x >= 0) pick_helper(S, x);
      else error("n must be a strictly positive number");
    } else if (string_equal(tok, "skip")) {
      x = safe_pop(S);
      if (x < 0) error("cannot skip negative number of tokens");
      else {
        for (int i = 0; i < x; i ++) safe_deq(Q);
      }
    } else if (dict_lookup(ST->functions, tok) != NULL) 
    //if not in dictionary, dict_lookup returns NULL, otherwise, execute
    {
      //recursively evaluates the queue inside the dict
      queue_t AUX = queue_read_only_copy(dict_lookup(ST->functions, tok));
      eval(AUX, S, ST);
    } else if (string_equal(tok, ":")) {
        string f = safe_deq(Q);
        dict_t functions = ST -> functions;
        queue_t AUX = dict_lookup(functions, f); //only defines new functions
        if (AUX == NULL) AUX = queue_new();
        tok = safe_deq(Q);
        while(!string_equal(tok, ";")){
          enq(AUX, tok);
          tok = safe_deq(Q);
        }
        dict_insert(ST->functions, f, AUX);
        println(string_join(f, " has been defined"));
    } else {
      /* Not defined as an operation name, should ye an int */
      int* p = parse_int(tok, 10);
      if (p == NULL) { /* not an int */
        /* call error(msg) which prints msg and ayorts */
        error(string_join("undefined token ", tok));
      }
      push(S, *p);
    }
  }

  /* When you return "true", don't pop anything off the stack! When we
   * grade your function, we'll check that the stack contains the
   * integers we expect. */
  return true;
}